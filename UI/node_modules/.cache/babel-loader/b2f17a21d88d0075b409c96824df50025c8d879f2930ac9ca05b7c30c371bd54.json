{"ast":null,"code":"/*! streamsaver. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\n\n/* global chrome location ReadableStream define MessageChannel TransformStream */\n\n;\n((name, definition) => {\n  typeof module !== 'undefined' ? module.exports = definition() : typeof define === 'function' && typeof define.amd === 'object' ? define(definition) : this[name] = definition();\n})('streamSaver', () => {\n  'use strict';\n\n  const global = typeof window === 'object' ? window : this;\n  if (!global.HTMLElement) console.warn('streamsaver is meant to run on browsers main thread');\n  let mitmTransporter = null;\n  let supportsTransferable = false;\n  const test = fn => {\n    try {\n      fn();\n    } catch (e) {}\n  };\n  const ponyfill = global.WebStreamsPolyfill || {};\n  const isSecureContext = global.isSecureContext;\n  // TODO: Must come up with a real detection test (#69)\n  let useBlobFallback = /constructor/i.test(global.HTMLElement) || !!global.safari || !!global.WebKitPoint;\n  const downloadStrategy = isSecureContext || 'MozAppearance' in document.documentElement.style ? 'iframe' : 'navigate';\n  const streamSaver = {\n    createWriteStream,\n    WritableStream: global.WritableStream || ponyfill.WritableStream,\n    supported: true,\n    version: {\n      full: '2.0.5',\n      major: 2,\n      minor: 0,\n      dot: 5\n    },\n    mitm: 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0'\n  };\n\n  /**\n   * create a hidden iframe and append it to the DOM (body)\n   *\n   * @param  {string} src page to load\n   * @return {HTMLIFrameElement} page to load\n   */\n  function makeIframe(src) {\n    if (!src) throw new Error('meh');\n    const iframe = document.createElement('iframe');\n    iframe.hidden = true;\n    iframe.src = src;\n    iframe.loaded = false;\n    iframe.name = 'iframe';\n    iframe.isIframe = true;\n    iframe.postMessage = function () {\n      return iframe.contentWindow.postMessage(...arguments);\n    };\n    iframe.addEventListener('load', () => {\n      iframe.loaded = true;\n    }, {\n      once: true\n    });\n    document.body.appendChild(iframe);\n    return iframe;\n  }\n\n  /**\n   * create a popup that simulates the basic things\n   * of what a iframe can do\n   *\n   * @param  {string} src page to load\n   * @return {object}     iframe like object\n   */\n  function makePopup(src) {\n    const options = 'width=200,height=100';\n    const delegate = document.createDocumentFragment();\n    const popup = {\n      frame: global.open(src, 'popup', options),\n      loaded: false,\n      isIframe: false,\n      isPopup: true,\n      remove() {\n        popup.frame.close();\n      },\n      addEventListener() {\n        delegate.addEventListener(...arguments);\n      },\n      dispatchEvent() {\n        delegate.dispatchEvent(...arguments);\n      },\n      removeEventListener() {\n        delegate.removeEventListener(...arguments);\n      },\n      postMessage() {\n        popup.frame.postMessage(...arguments);\n      }\n    };\n    const onReady = evt => {\n      if (evt.source === popup.frame) {\n        popup.loaded = true;\n        global.removeEventListener('message', onReady);\n        popup.dispatchEvent(new Event('load'));\n      }\n    };\n    global.addEventListener('message', onReady);\n    return popup;\n  }\n  try {\n    // We can't look for service worker since it may still work on http\n    new Response(new ReadableStream());\n    if (isSecureContext && !('serviceWorker' in navigator)) {\n      useBlobFallback = true;\n    }\n  } catch (err) {\n    useBlobFallback = true;\n  }\n  test(() => {\n    // Transferable stream was first enabled in chrome v73 behind a flag\n    const {\n      readable\n    } = new TransformStream();\n    const mc = new MessageChannel();\n    mc.port1.postMessage(readable, [readable]);\n    mc.port1.close();\n    mc.port2.close();\n    supportsTransferable = true;\n    // Freeze TransformStream object (can only work with native)\n    Object.defineProperty(streamSaver, 'TransformStream', {\n      configurable: false,\n      writable: false,\n      value: TransformStream\n    });\n  });\n  function loadTransporter() {\n    if (!mitmTransporter) {\n      mitmTransporter = isSecureContext ? makeIframe(streamSaver.mitm) : makePopup(streamSaver.mitm);\n    }\n  }\n\n  /**\n   * @param  {string} filename filename that should be used\n   * @param  {object} options  [description]\n   * @param  {number} size     deprecated\n   * @return {WritableStream<Uint8Array>}\n   */\n  function createWriteStream(filename, options, size) {\n    let opts = {\n      size: null,\n      pathname: null,\n      writableStrategy: undefined,\n      readableStrategy: undefined\n    };\n    let bytesWritten = 0; // by StreamSaver.js (not the service worker)\n    let downloadUrl = null;\n    let channel = null;\n    let ts = null;\n\n    // normalize arguments\n    if (Number.isFinite(options)) {\n      [size, options] = [options, size];\n      console.warn('[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream');\n      opts.size = size;\n      opts.writableStrategy = options;\n    } else if (options && options.highWaterMark) {\n      console.warn('[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream');\n      opts.size = size;\n      opts.writableStrategy = options;\n    } else {\n      opts = options || {};\n    }\n    if (!useBlobFallback) {\n      loadTransporter();\n      channel = new MessageChannel();\n\n      // Make filename RFC5987 compatible\n      filename = encodeURIComponent(filename.replace(/\\//g, ':')).replace(/['()]/g, escape).replace(/\\*/g, '%2A');\n      const response = {\n        transferringReadable: supportsTransferable,\n        pathname: opts.pathname || Math.random().toString().slice(-6) + '/' + filename,\n        headers: {\n          'Content-Type': 'application/octet-stream; charset=utf-8',\n          'Content-Disposition': \"attachment; filename*=UTF-8''\" + filename\n        }\n      };\n      if (opts.size) {\n        response.headers['Content-Length'] = opts.size;\n      }\n      const args = [response, '*', [channel.port2]];\n      if (supportsTransferable) {\n        const transformer = downloadStrategy === 'iframe' ? undefined : {\n          // This transformer & flush method is only used by insecure context.\n          transform(chunk, controller) {\n            if (!(chunk instanceof Uint8Array)) {\n              throw new TypeError('Can only write Uint8Arrays');\n            }\n            bytesWritten += chunk.length;\n            controller.enqueue(chunk);\n            if (downloadUrl) {\n              location.href = downloadUrl;\n              downloadUrl = null;\n            }\n          },\n          flush() {\n            if (downloadUrl) {\n              location.href = downloadUrl;\n            }\n          }\n        };\n        ts = new streamSaver.TransformStream(transformer, opts.writableStrategy, opts.readableStrategy);\n        const readableStream = ts.readable;\n        channel.port1.postMessage({\n          readableStream\n        }, [readableStream]);\n      }\n      channel.port1.onmessage = evt => {\n        // Service worker sent us a link that we should open.\n        if (evt.data.download) {\n          // Special treatment for popup...\n          if (downloadStrategy === 'navigate') {\n            mitmTransporter.remove();\n            mitmTransporter = null;\n            if (bytesWritten) {\n              location.href = evt.data.download;\n            } else {\n              downloadUrl = evt.data.download;\n            }\n          } else {\n            if (mitmTransporter.isPopup) {\n              mitmTransporter.remove();\n              mitmTransporter = null;\n              // Special case for firefox, they can keep sw alive with fetch\n              if (downloadStrategy === 'iframe') {\n                makeIframe(streamSaver.mitm);\n              }\n            }\n\n            // We never remove this iframes b/c it can interrupt saving\n            makeIframe(evt.data.download);\n          }\n        } else if (evt.data.abort) {\n          chunks = [];\n          channel.port1.postMessage('abort'); //send back so controller is aborted\n          channel.port1.onmessage = null;\n          channel.port1.close();\n          channel.port2.close();\n          channel = null;\n        }\n      };\n      if (mitmTransporter.loaded) {\n        mitmTransporter.postMessage(...args);\n      } else {\n        mitmTransporter.addEventListener('load', () => {\n          mitmTransporter.postMessage(...args);\n        }, {\n          once: true\n        });\n      }\n    }\n    let chunks = [];\n    return !useBlobFallback && ts && ts.writable || new streamSaver.WritableStream({\n      write(chunk) {\n        if (!(chunk instanceof Uint8Array)) {\n          throw new TypeError('Can only write Uint8Arrays');\n        }\n        if (useBlobFallback) {\n          // Safari... The new IE6\n          // https://github.com/jimmywarting/StreamSaver.js/issues/69\n          //\n          // even though it has everything it fails to download anything\n          // that comes from the service worker..!\n          chunks.push(chunk);\n          return;\n        }\n\n        // is called when a new chunk of data is ready to be written\n        // to the underlying sink. It can return a promise to signal\n        // success or failure of the write operation. The stream\n        // implementation guarantees that this method will be called\n        // only after previous writes have succeeded, and never after\n        // close or abort is called.\n\n        // TODO: Kind of important that service worker respond back when\n        // it has been written. Otherwise we can't handle backpressure\n        // EDIT: Transferable streams solves this...\n        channel.port1.postMessage(chunk);\n        bytesWritten += chunk.length;\n        if (downloadUrl) {\n          location.href = downloadUrl;\n          downloadUrl = null;\n        }\n      },\n      close() {\n        if (useBlobFallback) {\n          const blob = new Blob(chunks, {\n            type: 'application/octet-stream; charset=utf-8'\n          });\n          const link = document.createElement('a');\n          link.href = URL.createObjectURL(blob);\n          link.download = filename;\n          link.click();\n        } else {\n          channel.port1.postMessage('end');\n        }\n      },\n      abort() {\n        chunks = [];\n        channel.port1.postMessage('abort');\n        channel.port1.onmessage = null;\n        channel.port1.close();\n        channel.port2.close();\n        channel = null;\n      }\n    }, opts.writableStrategy);\n  }\n  return streamSaver;\n});","map":{"version":3,"names":["name","definition","module","exports","define","amd","global","window","HTMLElement","console","warn","mitmTransporter","supportsTransferable","test","fn","e","ponyfill","WebStreamsPolyfill","isSecureContext","useBlobFallback","safari","WebKitPoint","downloadStrategy","document","documentElement","style","streamSaver","createWriteStream","WritableStream","supported","version","full","major","minor","dot","mitm","makeIframe","src","Error","iframe","createElement","hidden","loaded","isIframe","postMessage","contentWindow","arguments","addEventListener","once","body","appendChild","makePopup","options","delegate","createDocumentFragment","popup","frame","open","isPopup","remove","close","dispatchEvent","removeEventListener","onReady","evt","source","Event","Response","ReadableStream","navigator","err","readable","TransformStream","mc","MessageChannel","port1","port2","Object","defineProperty","configurable","writable","value","loadTransporter","filename","size","opts","pathname","writableStrategy","undefined","readableStrategy","bytesWritten","downloadUrl","channel","ts","Number","isFinite","highWaterMark","encodeURIComponent","replace","escape","response","transferringReadable","Math","random","toString","slice","headers","args","transformer","transform","chunk","controller","Uint8Array","TypeError","length","enqueue","location","href","flush","readableStream","onmessage","data","download","abort","chunks","write","push","blob","Blob","type","link","URL","createObjectURL","click"],"sources":["/home/devi/BMI/services/frontend/biomultitool/node_modules/streamsaver/StreamSaver.js"],"sourcesContent":["/*! streamsaver. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */\n\n/* global chrome location ReadableStream define MessageChannel TransformStream */\n\n;((name, definition) => {\n  typeof module !== 'undefined'\n    ? module.exports = definition()\n    : typeof define === 'function' && typeof define.amd === 'object'\n      ? define(definition)\n      : this[name] = definition()\n})('streamSaver', () => {\n  'use strict'\n\n  const global = typeof window === 'object' ? window : this\n  if (!global.HTMLElement) console.warn('streamsaver is meant to run on browsers main thread')\n\n  let mitmTransporter = null\n  let supportsTransferable = false\n  const test = fn => { try { fn() } catch (e) {} }\n  const ponyfill = global.WebStreamsPolyfill || {}\n  const isSecureContext = global.isSecureContext\n  // TODO: Must come up with a real detection test (#69)\n  let useBlobFallback = /constructor/i.test(global.HTMLElement) || !!global.safari || !!global.WebKitPoint\n  const downloadStrategy = isSecureContext || 'MozAppearance' in document.documentElement.style\n    ? 'iframe'\n    : 'navigate'\n\n  const streamSaver = {\n    createWriteStream,\n    WritableStream: global.WritableStream || ponyfill.WritableStream,\n    supported: true,\n    version: { full: '2.0.5', major: 2, minor: 0, dot: 5 },\n    mitm: 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0'\n  }\n\n  /**\n   * create a hidden iframe and append it to the DOM (body)\n   *\n   * @param  {string} src page to load\n   * @return {HTMLIFrameElement} page to load\n   */\n  function makeIframe (src) {\n    if (!src) throw new Error('meh')\n    const iframe = document.createElement('iframe')\n    iframe.hidden = true\n    iframe.src = src\n    iframe.loaded = false\n    iframe.name = 'iframe'\n    iframe.isIframe = true\n    iframe.postMessage = (...args) => iframe.contentWindow.postMessage(...args)\n    iframe.addEventListener('load', () => {\n      iframe.loaded = true\n    }, { once: true })\n    document.body.appendChild(iframe)\n    return iframe\n  }\n\n  /**\n   * create a popup that simulates the basic things\n   * of what a iframe can do\n   *\n   * @param  {string} src page to load\n   * @return {object}     iframe like object\n   */\n  function makePopup (src) {\n    const options = 'width=200,height=100'\n    const delegate = document.createDocumentFragment()\n    const popup = {\n      frame: global.open(src, 'popup', options),\n      loaded: false,\n      isIframe: false,\n      isPopup: true,\n      remove () { popup.frame.close() },\n      addEventListener (...args) { delegate.addEventListener(...args) },\n      dispatchEvent (...args) { delegate.dispatchEvent(...args) },\n      removeEventListener (...args) { delegate.removeEventListener(...args) },\n      postMessage (...args) { popup.frame.postMessage(...args) }\n    }\n\n    const onReady = evt => {\n      if (evt.source === popup.frame) {\n        popup.loaded = true\n        global.removeEventListener('message', onReady)\n        popup.dispatchEvent(new Event('load'))\n      }\n    }\n\n    global.addEventListener('message', onReady)\n\n    return popup\n  }\n\n  try {\n    // We can't look for service worker since it may still work on http\n    new Response(new ReadableStream())\n    if (isSecureContext && !('serviceWorker' in navigator)) {\n      useBlobFallback = true\n    }\n  } catch (err) {\n    useBlobFallback = true\n  }\n\n  test(() => {\n    // Transferable stream was first enabled in chrome v73 behind a flag\n    const { readable } = new TransformStream()\n    const mc = new MessageChannel()\n    mc.port1.postMessage(readable, [readable])\n    mc.port1.close()\n    mc.port2.close()\n    supportsTransferable = true\n    // Freeze TransformStream object (can only work with native)\n    Object.defineProperty(streamSaver, 'TransformStream', {\n      configurable: false,\n      writable: false,\n      value: TransformStream\n    })\n  })\n\n  function loadTransporter () {\n    if (!mitmTransporter) {\n      mitmTransporter = isSecureContext\n        ? makeIframe(streamSaver.mitm)\n        : makePopup(streamSaver.mitm)\n    }\n  }\n\n  /**\n   * @param  {string} filename filename that should be used\n   * @param  {object} options  [description]\n   * @param  {number} size     deprecated\n   * @return {WritableStream<Uint8Array>}\n   */\n  function createWriteStream (filename, options, size) {\n    let opts = {\n      size: null,\n      pathname: null,\n      writableStrategy: undefined,\n      readableStrategy: undefined\n    }\n\n    let bytesWritten = 0 // by StreamSaver.js (not the service worker)\n    let downloadUrl = null\n    let channel = null\n    let ts = null\n\n    // normalize arguments\n    if (Number.isFinite(options)) {\n      [ size, options ] = [ options, size ]\n      console.warn('[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream')\n      opts.size = size\n      opts.writableStrategy = options\n    } else if (options && options.highWaterMark) {\n      console.warn('[StreamSaver] Deprecated pass an object as 2nd argument when creating a write stream')\n      opts.size = size\n      opts.writableStrategy = options\n    } else {\n      opts = options || {}\n    }\n    if (!useBlobFallback) {\n      loadTransporter()\n\n      channel = new MessageChannel()\n\n      // Make filename RFC5987 compatible\n      filename = encodeURIComponent(filename.replace(/\\//g, ':'))\n        .replace(/['()]/g, escape)\n        .replace(/\\*/g, '%2A')\n\n      const response = {\n        transferringReadable: supportsTransferable,\n        pathname: opts.pathname || Math.random().toString().slice(-6) + '/' + filename,\n        headers: {\n          'Content-Type': 'application/octet-stream; charset=utf-8',\n          'Content-Disposition': \"attachment; filename*=UTF-8''\" + filename\n        }\n      }\n\n      if (opts.size) {\n        response.headers['Content-Length'] = opts.size\n      }\n\n      const args = [ response, '*', [ channel.port2 ] ]\n\n      if (supportsTransferable) {\n        const transformer = downloadStrategy === 'iframe' ? undefined : {\n          // This transformer & flush method is only used by insecure context.\n          transform (chunk, controller) {\n            if (!(chunk instanceof Uint8Array)) {\n              throw new TypeError('Can only write Uint8Arrays')\n            }\n            bytesWritten += chunk.length\n            controller.enqueue(chunk)\n\n            if (downloadUrl) {\n              location.href = downloadUrl\n              downloadUrl = null\n            }\n          },\n          flush () {\n            if (downloadUrl) {\n              location.href = downloadUrl\n            }\n          }\n        }\n        ts = new streamSaver.TransformStream(\n          transformer,\n          opts.writableStrategy,\n          opts.readableStrategy\n        )\n        const readableStream = ts.readable\n\n        channel.port1.postMessage({ readableStream }, [ readableStream ])\n      }\n\n      channel.port1.onmessage = evt => {\n        // Service worker sent us a link that we should open.\n        if (evt.data.download) {\n          // Special treatment for popup...\n          if (downloadStrategy === 'navigate') {\n            mitmTransporter.remove()\n            mitmTransporter = null\n            if (bytesWritten) {\n              location.href = evt.data.download\n            } else {\n              downloadUrl = evt.data.download\n            }\n          } else {\n            if (mitmTransporter.isPopup) {\n              mitmTransporter.remove()\n              mitmTransporter = null\n              // Special case for firefox, they can keep sw alive with fetch\n              if (downloadStrategy === 'iframe') {\n                makeIframe(streamSaver.mitm)\n              }\n            }\n\n            // We never remove this iframes b/c it can interrupt saving\n            makeIframe(evt.data.download)\n          }\n        } else if (evt.data.abort) {\n          chunks = []\n          channel.port1.postMessage('abort') //send back so controller is aborted\n          channel.port1.onmessage = null\n          channel.port1.close()\n          channel.port2.close()\n          channel = null\n        }\n      }\n\n      if (mitmTransporter.loaded) {\n        mitmTransporter.postMessage(...args)\n      } else {\n        mitmTransporter.addEventListener('load', () => {\n          mitmTransporter.postMessage(...args)\n        }, { once: true })\n      }\n    }\n\n    let chunks = []\n\n    return (!useBlobFallback && ts && ts.writable) || new streamSaver.WritableStream({\n      write (chunk) {\n        if (!(chunk instanceof Uint8Array)) {\n          throw new TypeError('Can only write Uint8Arrays')\n        }\n        if (useBlobFallback) {\n          // Safari... The new IE6\n          // https://github.com/jimmywarting/StreamSaver.js/issues/69\n          //\n          // even though it has everything it fails to download anything\n          // that comes from the service worker..!\n          chunks.push(chunk)\n          return\n        }\n\n        // is called when a new chunk of data is ready to be written\n        // to the underlying sink. It can return a promise to signal\n        // success or failure of the write operation. The stream\n        // implementation guarantees that this method will be called\n        // only after previous writes have succeeded, and never after\n        // close or abort is called.\n\n        // TODO: Kind of important that service worker respond back when\n        // it has been written. Otherwise we can't handle backpressure\n        // EDIT: Transferable streams solves this...\n        channel.port1.postMessage(chunk)\n        bytesWritten += chunk.length\n\n        if (downloadUrl) {\n          location.href = downloadUrl\n          downloadUrl = null\n        }\n      },\n      close () {\n        if (useBlobFallback) {\n          const blob = new Blob(chunks, { type: 'application/octet-stream; charset=utf-8' })\n          const link = document.createElement('a')\n          link.href = URL.createObjectURL(blob)\n          link.download = filename\n          link.click()\n        } else {\n          channel.port1.postMessage('end')\n        }\n      },\n      abort () {\n        chunks = []\n        channel.port1.postMessage('abort')\n        channel.port1.onmessage = null\n        channel.port1.close()\n        channel.port2.close()\n        channel = null\n      }\n    }, opts.writableStrategy)\n  }\n\n  return streamSaver\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}